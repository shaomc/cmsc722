/* *****************************************************************************
 * A.L.E (Atari 2600 Learning Environment)
 * Copyright (c) 2009-2010 by Yavar Naddaf
 * Released under GNU General Public License www.gnu.org/licenses/gpl-3.0.txt
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  class_shape.cpp
 *
 *  Represents one of the 2D shapes of a class.
 *  A sorted lists of these are imported from our class-discovery code, 
 *  currently implemented in Python.
 **************************************************************************** */

#include <sstream>
#include <fstream>
#include "class_shape.h"




/* *********************************************************************
    Constructor: generates a ClassShape object from the imported text
    from a text file. The string format is as follows:
        class_num,width,height|
        M[0,0], M[0,1], ..., M[0,n]|
        M[1,0], M[1,1], ..., M[1,n]|
        ...
        M[m,0], M[m,1], ..., M[m,n]|
 ******************************************************************** */
ClassShape::ClassShape( string& imported_txt) {
    istringstream stream(imported_txt);
   char delim;
    stream >> i_instance_of_class;
    stream.get(delim);
    if (delim != ',') {
        complain_and_exit(imported_txt);
    }
    stream >> i_width;
    stream.get(delim);
    if (delim != ',') {
        complain_and_exit(imported_txt);
    }
    stream >> i_height;
    stream.get(delim);
    if (delim != '|') {
        complain_and_exit(imported_txt);
    }
    if (i_width <= 0 || i_height <= 0) {
        complain_and_exit(imported_txt);
    }
    // Import the shape matrix
    pm_shape = new IntMatrix;
    int bit_val;
    for(int i = 0; i < i_height; i++) {
        IntVect row;
        for(int j = 0; j < i_width; j++) {
            stream >> bit_val;
            if (bit_val != 0 && bit_val != 1) {
                complain_and_exit(imported_txt);
            }
            stream.get(delim);
            if ((j < (i_width - 1) && delim != ',') ||
                (j == (i_width - 1) && delim != '|'))  {
                complain_and_exit(imported_txt);
            }
            row.push_back(bit_val);
        }
        pm_shape->push_back(row);
    }
    // find i_first_one_ind
    i_first_one_ind = -1;
    for(int j = 0; j < i_width; j++) {
        if ((*pm_shape)[0][j] == 1) {
            i_first_one_ind = j;
        }
    }
    if (i_first_one_ind == -1) {
        complain_and_exit(imported_txt);
    }
    
    cout << "shape imported successfully :)" << endl;
}

/* *********************************************************************
    Deconstructor
 ******************************************************************** */        
ClassShape::~ClassShape() {
    if (pm_shape) {
        delete pm_shape;
    }
}

/* *********************************************************************
    Prints the shape matrix
 ******************************************************************** */        
void ClassShape::print_shape(void) {
    cout << "Instance of Class #"  << i_instance_of_class << endl;
    cout << "width = " << i_width << " - height = " << i_height << endl;
    for(int i = 0; i < i_height; i++) {
        cout << "\t";
        for(int j = 0; j < i_width; j++) {
            cout << (*pm_shape)[i][j];
        }
        cout << endl;
    }
}
        


/* *********************************************************************
    Complains about the format of the import text and exits
 ******************************************************************** */        
void ClassShape::complain_and_exit(string& imported_txt) {
    cerr << "Bad format in the given class-shape import text: " << endl;
    cerr << "\t" << imported_txt << endl;
    cerr << "The proper string format is as follows: " << endl;
    cerr << "    width,height| " << endl;
    cerr << "    M[0,0], M[0,1], ..., M[0,n]| " << endl;
    cerr << "    M[1,0], M[1,1], ..., M[1,n]| " << endl;
    cerr << "    ... " << endl;
    cerr << "    M[m,0], M[m,1], ..., M[m,n]| " << endl;
    exit(-1);
}


/* *********************************************************************
    Imports the list of class shapes from a text file. This file is 
    currently generated by our Python class-discovery code.
    File format is:
        number_of_classes,number_of_shapes\n
        shape_matrix_text_1 (see the comments on constructor) \n
        shape_matrix_text_2\n
        ...
        shape_matrix_text_n
    Note: The caller is responsible for deleting the returned list,
            as well as all the ClassShape objects generated on the heap
 ******************************************************************** */        
ShapeList* ClassShape::import_shape_list(string filename, int& num_classes) {
    ifstream infile;
	infile.open(filename.c_str());
    string err_str = "Unable to import class-shapes from the given file:" + 
                    filename;
    if (!infile) {
        throw err_str;
    }
    infile >> num_classes;
    if (num_classes <= 0) {
        throw err_str;
    }
    char delim;
    infile.get(delim);
    if (delim != ',') {
        throw err_str;
    }
    int num_shapes;
    infile >> num_shapes;
    if (num_shapes <= 0) {
        throw err_str;
    }
    ShapeList* shape_list = new ShapeList;
    char buff_chr[524288];
    for (int i = 0; i < num_shapes; i++) {
        infile.ignore(1); // ignore \n
        infile.get(buff_chr, 524200, '\n');
        string str = string(buff_chr);
        ClassShape* p_new_class_shape = new ClassShape(str);
        p_new_class_shape->print_shape();
        shape_list->push_back(p_new_class_shape);
    }
    return shape_list;
}

